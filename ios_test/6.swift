/**==================================================================
 [1번 문제]
  - 클래스(Class)와 구조체(Struct)의 차이점은? 가장 중요한 차이점 위주로 간단하게 서술.
 ===================================================================**/

// 클래스(Class)와 구조체(Struct)의 가장 중요한 차이점은 참조(reference)와 값(value)의 차이. 
// 클래스는 참조 타입(reference type)으로, 인스턴스가 메모리의 동일한 위치를 참조하여 수정할 수 있음. 
// 반면 구조체는 값 타입(value type)으로, 인스턴스가 복사되어 각기 다른 메모리 위치에 저장됨. 
// 이로 인해 클래스는 상속을 지원하지만, 구조체는 상속을 지원하지 않는ㄷㅏ.








/**==================================================================
 [2번 문제]
  - 아래의 코드 예제에서, Bclass는 Aclass를 상속하고 있다. Bclass의 저장속성인
    z를 고려해서, Bclass의 지정생성자를 한개이상 구현하고, 상위(Aclass)의 지정생성자
    (init(x: Int, y: Int))를 "지정생성자"(⭐️)로 재정의.
    (편의생성자 아님! 내부는 자유롭게 구현.)
 ===================================================================**/


class Aclass {
    var x: Int
    var y: Int
    
    init(x: Int, y: Int) {
        self.x = x
        self.y = y
    }
    
    convenience init() {
        self.init(x: 0, y: 0)
    }
}



// 아래의 주석을 제거하고 코드를 구현

class Bclass: Aclass {

   var z: Int

   // 이 부분에 지정생성자를 2개 (상위의 지정생성자를 재정의한 것 포함) 구현

   // 지정생성자 1: 상위의 지정생성자를 재정의
    init(x: Int, y: Int, z: Int) {
        self.z = z
        super.init(x: x, y: y)
    }

    // 지정생성자 2: 기본값을 사용하는 생성자
    init(z: Int) {
        self.z = z
        super.init(x: 0, y: 0) // 기본값 사용
    }

}




/**==================================================================
 [3번 문제]
  - 아래 Hero 클래스가 구현되어 있습니다. 해당 Hero클래스는 이름(name)과 아이디(id)로
    인스턴스를 생성할 수 있는데, 해당 클래스를 확장(Extension)해서,
    이름만으로도 인스턴스를 생성할 수 있는.. (확장에서) 생성자를 구현.
    (아이디는 0으로 셋팅되도록 구현.)
    (힌트. 확장에서, 생성자의 구현에서, 주의할점은...?)
 ===================================================================**/



class Hero {
    var name: String
    var id: Int
    
    init(name: String, id: Int) {
        self.name = name
        self.id = id
    }
}

extension Hero {
    // 이 부분을 이름만 가지고 생성할 수 있는 생성자로 구현.

    convenience init(name: String) {
        self.init(name: name, id: 0) // 아이디는 0으로 설정
    }
    
}


var hero1 = Hero(name: "아이언맨", id: 0)
var hero2 = Hero(name: "캡틴아메리카", id: 1)
var hero3 = Hero(name: "헐크", id: 2)



// 위의 확장에서, 생성자를 제대로 구현하면 아래의 코드가 사용 가능해 짐.
//var hero4 = Hero(name: "토르")
//var hero5 = Hero(name: "스파이더맨")



/**==================================================================
 [4번 문제]
  - Any와 AnyObject타입의 차이는 뭔가요? 아는대로 간단하게 서술.
 ===================================================================**/

// Any는 Swift의 모든 데이터 타입을 나타낼 수 있는 타입이며, 값의 타입을 특정할 수 없다. 
// 반면 AnyObject는 클래스 타입의 인스턴스를 나타내며, 모든 클래스 타입의 객체를 포함할 수 있다. 
// 즉, Any는 값 타입과 클래스 타입 모두를 포함할 수 있지만, AnyObject는 오직 클래스 타입만 포함할 수 있다.







/**==================================================================
 [5번 문제]
  - 아래의 조건을 만족하는 RemoteControl 프로토콜의 구현을 완성.
    (조건)
    (1) name 속성(타입: String)을 요구사항으로 선언
        (최소한의 요구사항은 읽기 속성 강제하기)
    (2) turnOn 메서드를 요구사항으로 선언
        (input: 없음, output: Bool)
    (3) turnOff 메서드를 요구사항으로 선언
        (input: (num: Int), output: Bool)
 ===================================================================**/

// RemoteControl 프로토콜
protocol RemoteControl {
    // 이 내부의 코드를 완성.
    var name: String { get } // 읽기 속성 요구
    
    func turnOn() -> Bool // turnOn 메서드 요구
    func turnOff(num: Int) -> Bool // turnOff 메서드 요구
    
}






/**==================================================================
 [6번 문제]
  - 프로토콜(Protocol)의 확장(Extension)이 어떤 개념인가요? 아는대로 간단하게 서술.
 ===================================================================**/

// 프로토콜의 확장은 기존 프로토콜에 새로운 메서드, 프로퍼티, 또는 기본 구현을 추가할 수 있게 해주는 기능. 
// 프로토콜을 채택한 모든 타입에서 일관된 기능을 사용할 수 있고, 코드의 재사용성을 높일 수 있다.










/**==================================================================
 [7번 문제]
  - 고차함수를 사용해서, 아래 array배열에서, 5보다 큰 짝수를 뽑기. 해당 뽑아낸
    숫자들을 evenNumbersArray 변수에 담으면 됨.
    (힌트. 고차함수 두번 사용 가능)
 ===================================================================**/

let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]


// 아래, array 배열에 고차함수 사용하는 코드 완성.
// var evenNumbersArray = array // [이 부분을 지우고, 고차함수로 완성하시면 됨.]

// 고차함수를 사용한 코드
var evenNumbersArray = array.filter { $0 > 5 }.filter { $0 % 2 == 0 }


// 이 코드는 출력(확인)을 위한 코드.
print(evenNumbersArray)







/**==================================================================
 [8번 문제]
  - 아래 Student구조체가 정의되어 있고, 해당 구조체의 인스턴스를 담고 있는
    someMembers 배열이 있다. someMembers 배열에서, 고차함수 방식을 이용해서
    친구의 이름이 "아이브"를 가진 멤버만 뽑아내서, 출력.
 
  - 힌트. (1) someMembers.고차함수 사용  (2) contains 메서드
 
  - 고차함수로 잘 완성을 했다면, 그 아래 newMembers.map { print($0.name) }
    이 부분을 통해서, "잡스", "팀쿡" 이 두명의 이름을 정상적으로 출력을 할 수 있다.
 ===================================================================**/


struct Student {
    let name: String
    let studentId: Int
    let friendsName: [String]
}


let someMembers: [Student] = [
    Student(name: "잡스", studentId: 0, friendsName: ["팀쿡", "아이브"]),
    Student(name: "팀쿡", studentId: 0, friendsName: ["잡스", "아이브"]),
    Student(name: "주커버그", studentId: 0, friendsName: ["빌게이츠", "마이클"]),
    Student(name: "베조스", studentId: 0, friendsName: ["빌게이츠", "존"])
]



// 아래, someClassMembers 배열에 고차함수 사용하는 코드 완성하기.
// var newMembers = someMembers  // [이 부분을 지우고, 고차함수로 완성.]

var newMembers = someMembers.filter { $0.friendsName.contains("아이브") }

// 이 코드는 출력(확인)을 위한 코드.
//newMembers.map { print($0.name) }

// 잡스
// 팀쿡



/**==================================================================
 [9번 문제]
  - 반복문에서 for문 대신에 map, filter, reduce 를 사용할 수 있음. 각각을
    간단하게 설명.
 ===================================================================**/

// 1) map
// map은 배열의 각 요소에 동일한 함수를 적용하여 새로운 배열을 생성하는 함수. 
// 원본 배열은 수정하지 않고, 변형된 요소들로 이루어진 새 배열을 반환.

// 2) filter
// filter는 배열의 각 요소에 대해 특정 조건을 검사하여 조건에 맞는 요소만을 모아서 새로운 배열을 반환.

// 3) reduce
// reduce는 배열의 각 요소를 결합하여 단일 결과를 생성. 주로 총합, 평균, 곱셈 등 집계 작업을 수행할 때 사용됨.







/**==================================================================
 [10번 문제]
  - 클로저가 뭔가? 간단한 개념을 설명하고, 클로저에서 강한순환참조(Strong Reference Cycle)
    를 방지할려면 어떻게 해야 되는지
 ===================================================================**/

// 클로저는 코드에서 함수의 이름이 없이도 사용할 수 있는 익명 함수. 변수나 상수에 할당되어 매개변수, 반환형, 실행 코드로 구성됨. 
// 클로저는 참조 타입으로, 캡처된 외부 변수를 참조할 수 있다.

// 클로저에서 강한 순환 참조를 방지하려면 [weak self] 또는 [unowned self] 키워드를 사용하여 클로저 내부에서 self에 대한 강한 참조를 약하게 만듬. 
// 이를 통해 메모리 누수를 방지할 수 있다.






/**==================================================================
 [11번 문제]
  - 스위프트의 메모리 관리 모델인 ARC(Automatic Reference Counting) 시스템은
    무엇을 의미하는지? 아는대로 간단하게 서술.
 ===================================================================**/

// ARC(Automatic Reference Counting)는 Swift에서 메모리 관리를 자동화하는 시스템.
// 객체의 참조 횟수를 추적
// 사용 중인 객체는 유지하고 더 이상 참조되지 않는 객체는 자동으로 메모리에서 해제하여 메모리 누수를 방지.
// 강한 참조로 인해 객체가 서로를 참조.
// 해제되지 않는 상황에서는 약한 참조나 미소유 참조를 사용하여 순환 참조를 방지











/**==================================================================
 [12번 문제]
  - HTTP프로토콜이 뭔가? 아는대로 간단하게 서술.
 ===================================================================**/

// HTTP는 인터넷 상에서 웹 클라이언트와 서버 간에 데이터를 주고받기 위한 프로토콜.
// 주로 HTML 문서나 이미지, 비디오 같은 리소스들을 전송하는 데 사용
// 요청과 응답 구조로 동작
// HTTP는 상태를 유지하지 않는 비연결형 프로토콜.
















/**==================================================================
 [13번 문제]
  - 동시성(Concurrency) 프로그래밍이 왜 필요? 간단한 이유를 서술.
 ===================================================================**/

// 동시성 프로그래밍은 여러 작업을 동시에 처리하여 애플리케이션의 효율성을 높임
// 사용자가 앱을 더욱 빠르고 응답성 있게 느끼도록 돕기 위해 필요.
// 네트워크 요청이나 파일 입출력 같은 시간이 오래 걸리는 작업을 백그라운드에서 처리함. 
// 메인 스레드가 사용자의 인터페이스 응답에 집중할 수 있게 함.









/**==================================================================
 [14번 문제]
  - GCD Queue(대기열)가 뭔가? 아는대로 간단하게 서술.
    (힌트. Thread 쓰레드)
 ===================================================================**/

// GCD Queue는 여러 작업을 순서대로 또는 동시에 실행할 수 있는 작업 대기열.
// 스레드 관리와 동시성 처리를 효율적으로 수행.
// 시스템 자원을 최대한 활용할 수 있도록 지원하는 역할.
// 이를 통해 개발자는 스레드를 직접 관리하지 않고 병렬 처리와 비동기 작업을 구현.










/**==================================================================
 [15번 문제]
  - GCD Queue의 종류는 어떤게 있나? 아는대로 서술.
 ===================================================================**/

// 1) Serial Queue (직렬 큐)
//    - 작업을 하나씩 순서대로 처리하는 큐. 
//    - 한 번에 하나의 작업만 처리 특정 순서를 보장해야 하는 작업에 유용.
//
// 2) Concurrent Queue (동시 큐)
//    - 여러 작업을 동시에 실행할 수 있는 큐. 
//    - 작업이 준비되는 대로 가능한 만큼 병렬적으로 실행.
//    - 순서를 보장하지 않아도 되는 작업에 유용.
//
// 3) Main Queue (메인 큐)
//    - 메인 스레드에서 실행되는 직렬 큐.
//    - UI 업데이트와 같이 메인 스레드에서 실행되어야 하는 작업을 처리. 
//    - Main Queue는 반드시 메인 스레드에서 접근해야 함.






/**>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 앨런Swift문법 마스터 스쿨 주차 시험 참조
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>**/