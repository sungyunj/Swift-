/**==================================================================
 [1번 문제]
  - 아래의 코드 예제에서, Bclass는 Aclass를 상속하고 있다. Bclass의 저장속성인
    z를 고려해서, Bclass의 지정생성자를 한개이상 구현하고, 상위(Aclass)의 지정생성자
    (init(x: Int, y: Int))를 편의생성자로 재정의.
 ===================================================================**/


class Aclass {
    var x: Int
    var y: Int
    
    init(x: Int, y: Int) {
        self.x = x
        self.y = y
    }
    
    convenience init() {
        self.init(x: 0, y: 0)
    }
}



// 아래의 주석을 제거하고 코드를 구현
class Bclass: Aclass {

    var z: Int
    
    // 지정 생성자 구현
    init(x: Int, y: Int, z: Int) {
        self.z = z
        super.init(x: x, y: y)
    }
    
    // 편의 생성자 구현 (상위의 지정 생성자를 편의 생성자로 재정의)
    convenience override init(x: Int, y: Int) {
        self.init(x: x, y: y, z: 0)
    }
}




/**==================================================================
 [2번 문제]
  - 클래스에서 convenience(편의) 생성자는 어떤 개념인가? 간단하게 서술.
 ===================================================================**/


// 편의 생성자는 클래스의 지정 생성자를 호출하여 초기화를 보다 간편하게 수행할 수 있도록 돕는 생성자. 
// 지정 생성자와는 다르게 클래스 내에서만 호출이 가능하며, 
// 주로 동일한 클래스 내에서 여러 초기화 과정을 간소화하거나 기본값을 설정하는 데 사용







/**==================================================================
 [3번 문제]
  - 아래의 SubClass에서, 상위의 SuperClass의 sayHello 메서드를 재정의해서,
    아래 처럼 출력되도록 구현.
 
    "안녕하세요."   // super호출 코드로 구현
    "반갑습니다."
    "잘 부탁드려요."
 ===================================================================**/


class SuperClass {
    func sayHello() {
        print("안녕하세요.")
    }
}



class SubClass: SuperClass {
    // 메서드 재정의 코드 구현
    override func sayHello() {
        super.sayHello()
        print("반깁습니다.")
        print("잘 부탁드려요.")
    }
    
}


// 코드 실행
var subClass = SubClass()
subClass.sayHello()


// 원하는 출력
// "안녕하세요."
// "반갑습니다."
// "잘 부탁드려요."







/**==================================================================
 [4번 문제]
  - 스위프트의 기본 타입인 Int(정수형)를 확장해서, 언제든지 정수 인스턴스를 제곱(square)
    하는 함수를 만드려고 합니다. 아래, square함수의 내부 구현을 완성.
    (개념: 확장에서, 메서드 구현)
 ===================================================================**/

// 제곱하는 메서드 만들어 보기

extension Int {
    // 아래 제곱(square) 함수의 내부 구현을 완성.
    func square() -> Int {
        return self * self
    }
}


// 제대로 구현했는지 확인하는 코드
var someInt = 5
someInt.square()
print(someInt)
// (제대로 구현했다면) 5를 제곱하면, 결과로 25가 출력되면 됨.





/**==================================================================
 [5번 문제]
  - 아래 Hero 클래스가 구현되어 있다. 해당 Hero클래스는 이름(name)과 아이디(id)로
    인스턴스를 생성할 수 있는데, 해당 클래스를 확장(Extension)해서,
    이름만으로도 인스턴스를 생성할 수 있는.. (확장에서) 생성자를 구현.
    (아이디는 0으로 셋팅되도록 구현하면 됨.)
    (힌트. 확장에서, 생성자의 구현에서, 주의할점은...?)
 ===================================================================**/



class Hero {
    var name: String
    var id: Int
    
    init(name: String, id: Int) {
        self.name = name
        self.id = id
    }
}

extension Hero {
    // 이 부분을 이름만 가지고 생성할 수 있는 생성자로 구현.
    convenience init(name: String) {
        self.init(name: name, id: 0)
    }
    
}


var hero1 = Hero(name: "아이언맨", id: 0)
var hero2 = Hero(name: "캡틴아메리카", id: 1)
var hero3 = Hero(name: "헐크", id: 2)



// 위의 확장에서, 생성자를 제대로 구현하면 아래의 코드가 사용 가능해 짐.
var hero4 = Hero(name: "토르")
var hero5 = Hero(name: "스파이더맨")



/**==================================================================
 [6번 문제]
  - 메서드 디스패치(Method Dispatch)가 어떤 개념인가? 아는대로 서술.
    (1) Direct 디스패치, (2) Dynamic 디스패치 두가지의 차이점을 중심으로 설명.
 ===================================================================**/


// 메서드 디스패치는 객체가 특정 메서드를 호출할 때 그 메서드의 실행 방식을 결정하는 과정

// Direct 디스패치: 컴파일 타임에 메서드의 위치가 결정되어 바로 접근하여 실행하는 방식
// 빠른 성능을 보장하며, 보통 구조체와 열거형의 메서드가 해당

// Dynamic 디스패치: 런타임에 메서드의 위치가 결정되는 방식으로, 동적 바인딩을 사용하여 실행
// 클래스의 메서드는 주로 Dynamic 디스패치를 사용
// 이는 다형성을 지원하지만, 성능은 상대적으로 Direct 디스패치보다 떨어짐.






/**==================================================================
 [7번 문제]
  - 아래의 조건을 만족하는 RemoteControl 프로토콜의 구현을 완성.
    (조건)
    (1) name 속성(타입: String)을 요구사항으로 선언
        (최소한의 요구사항은 읽기 속성 강제하기)
    (2) turnOn 메서드를 요구사항으로 선언
        (input: 없음, output: Bool)
    (3) turnOff 메서드를 요구사항으로 선언
        (input: (num: Int), output: Bool)
 ===================================================================**/

// RemoteControl 프로토콜
protocol RemoteControl {
    // 이 내부의 코드를 완성.
    var name: String { get } // 읽기 전용 속성

    func turnOn() -> Bool
    func turnOff(num: Int) -> Bool
    
}







/**==================================================================
 [8번 문제]
  - 프로토콜(Protocol)의 확장(Extension)이 어떤 개념인가? 아는대로 간단하게 서술.
 ===================================================================**/

//












/**==================================================================
 [9번 문제]
  - 프로토콜(Protocol)지향 프로그래밍이 어떤 개념인가? 아는대로 간단하게 서술.
 ===================================================================**/

//













/**==================================================================
 [10번 문제]
  - 스위프트에서, 함수를 1급 객체로 취급한다는 의미가 어떤 의미인가? 아는대로 설명.
 ===================================================================**/

//










/**==================================================================
 [11번 문제]
  - 콜백(Call back)함수가 뭔가? 개념을 간단하게 서술.
 ===================================================================**/

//







/**==================================================================
 [12번 문제]
  - 고차함수를 사용해서, 아래 array배열에서, 5보다 큰 짝수를 뽑기. 해당 뽑아낸
    숫자들을 evenNumbersArray 변수에 담으면 됨.
    (힌트. 고차함수 두번 사용 가능)
 ===================================================================**/

let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]


// 아래, array 배열에 고차함수 사용하는 코드 완성.
var evenNumbersArray = array // [이 부분을 지우고, 고차함수로 완성하시면 됨.]




// 이 코드는 출력(확인)을 위한 코드.
print(evenNumbersArray)




/**==================================================================
 [13번 문제]
  - 고차함수를 사용해서, 아래 numbersArray배열에서, 홀수만 제곱해서, 그 숫자를 다
    더한 값을 도출하는 코드를 완성.
    numbersArray 배열에서 고차함수를 조합해서, 새로운 결과를 newResult 변수에 넣기.
 ===================================================================**/


var numbersArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]



var newResult = numbersArray  // [이 부분을 지우고, 고차함수로 완성하기.]
                    

// 이 코드는 출력(확인)을 위한 코드.
print(newResult)
// 165






/**==================================================================
 [14번 문제]
  - 아래 Student구조체가 정의되어 있고, 해당 구조체의 인스턴스를 담고 있는
    someMembers 배열이 있습니다. someMembers 배열에서, 고차함수 방식을 이용해서
    친구의 이름이 "아이브"를 가진 멤버만 뽑아내서, 출력을.
 
  - 힌트. (1) someMembers.고차함수 사용  (2) contains 메서드
 
  - 고차함수로 잘 완성을 했다면, 그 아래 newMembers.map { print($0.name) }
    이 부분을 통해서, "잡스", "팀쿡" 이 두명의 이름을 정상적으로 출력을 할 수 있음.
 ===================================================================**/


struct Student {
    let name: String
    let studentId: Int
    let friendsName: [String]
}


let someMembers: [Student] = [
    Student(name: "잡스", studentId: 0, friendsName: ["팀쿡", "아이브"]),
    Student(name: "팀쿡", studentId: 0, friendsName: ["잡스", "아이브"]),
    Student(name: "주커버그", studentId: 0, friendsName: ["빌게이츠", "마이클"]),
    Student(name: "베조스", studentId: 0, friendsName: ["빌게이츠", "존"])
]



// 아래, someClassMembers 배열에 고차함수 사용하는 코드 완성.
var newMembers = someMembers  // [이 부분을 지우고, 고차함수로 완성.]



// 이 코드는 출력(확인)을 위한 코드.
//newMembers.map { print($0.name) }

// 잡스
// 팀쿡




/**==================================================================
 [15번 문제]
  - 함수형 프로그래밍이 어떤 개념인가? 아는대로, 간단하게 서술.
 ===================================================================**/











/**>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 앨런Swift문법 마스터 스쿨 주차 시험 참조
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>**/
